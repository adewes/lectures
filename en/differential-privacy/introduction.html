<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content=
"width=device-width, initial-scale=1">
<title>Lectures | Differential Privacy - Introduction</title>
<link rel="stylesheet" type="text/css" href=
"/lectures/static/css/main.css">
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="/lectures/static/js/mathjax/tex-chtml.js" id=
"MathJax-script" async></script>
<style type="text/css">
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #8f5902; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #ef2929 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #204a87; font-weight: bold } /* Keyword */
.highlight .l { color: #000000 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #ce5c00; font-weight: bold } /* Operator */
.highlight .x { color: #000000 } /* Other */
.highlight .p { color: #000000; font-weight: bold } /* Punctuation */
.highlight .ch { color: #8f5902; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #8f5902; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #8f5902; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #8f5902; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #8f5902; font-style: italic } /* Comment.Single */
.highlight .cs { color: #8f5902; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #ef2929 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #a40000; font-weight: bold } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #204a87; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #204a87; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #204a87; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #204a87; font-weight: bold } /* Keyword.Type */
.highlight .ld { color: #000000 } /* Literal.Date */
.highlight .m { color: #0000cf; font-weight: bold } /* Literal.Number */
.highlight .s { color: #4e9a06 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #204a87 } /* Name.Builtin */
.highlight .nc { color: #000000 } /* Name.Class */
.highlight .no { color: #000000 } /* Name.Constant */
.highlight .nd { color: #5c35cc; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #ce5c00 } /* Name.Entity */
.highlight .ne { color: #cc0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #000000 } /* Name.Function */
.highlight .nl { color: #f57900 } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #204a87; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #000000 } /* Name.Variable */
.highlight .ow { color: #204a87; font-weight: bold } /* Operator.Word */
.highlight .pm { color: #000000; font-weight: bold } /* Punctuation.Marker */
.highlight .w { color: #f8f8f8 } /* Text.Whitespace */
.highlight .mb { color: #0000cf; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #0000cf; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #0000cf; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000cf; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #0000cf; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { color: #4e9a06 } /* Literal.String.Affix */
.highlight .sb { color: #4e9a06 } /* Literal.String.Backtick */
.highlight .sc { color: #4e9a06 } /* Literal.String.Char */
.highlight .dl { color: #4e9a06 } /* Literal.String.Delimiter */
.highlight .sd { color: #8f5902; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #4e9a06 } /* Literal.String.Double */
.highlight .se { color: #4e9a06 } /* Literal.String.Escape */
.highlight .sh { color: #4e9a06 } /* Literal.String.Heredoc */
.highlight .si { color: #4e9a06 } /* Literal.String.Interpol */
.highlight .sx { color: #4e9a06 } /* Literal.String.Other */
.highlight .sr { color: #4e9a06 } /* Literal.String.Regex */
.highlight .s1 { color: #4e9a06 } /* Literal.String.Single */
.highlight .ss { color: #4e9a06 } /* Literal.String.Symbol */
.highlight .bp { color: #3465a4 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #000000 } /* Name.Function.Magic */
.highlight .vc { color: #000000 } /* Name.Variable.Class */
.highlight .vg { color: #000000 } /* Name.Variable.Global */
.highlight .vi { color: #000000 } /* Name.Variable.Instance */
.highlight .vm { color: #000000 } /* Name.Variable.Magic */
.highlight .il { color: #0000cf; font-weight: bold } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div id="translation-notice">
<div class="message is-info">
<div class="message-body">
<p>This website was mostly translated automatically from the
<a href="/lectures/differential-privacy/einfuehrung">German
version</a>. We apologize for any translation errors.</p>
<span class="x" onclick=
"localStorage.setItem('translation-notice', true);notice.style.display = 'none'">x</span></div>
</div>
</div>
<script>
var notice = document.getElementById("translation-notice")
if (localStorage.getItem("translation-notice") === null && notice !== null){
        notice.style.display = "block"
}
</script>
<nav class="navbar is-dark">
<div class="navbar-brand"><a class="navbar-item" href=
"/lectures/en"><!--
<span class="cube is-red is-sm" style="display: block; margin: 0 auto; padding-top: 0px;">
  <span class="face front">&nbsp;</span>
  <span class="face side">&nbsp;</span>
  <span class="face top">&nbsp;</span>
</span>
-->
 Lectures</a> <span class="navbar-burger burger" data-target=
"side-menu" data-toggle="collapse"><span>&nbsp;</span>
<span>&nbsp;</span> <span>&nbsp;</span></span></div>
</nav>
<div class="main">
<div class="side-menu" id="side-menu" data-toggle-class=
"is-active">
<aside class="menu">
<p class="menu-label"><a href="/lectures/en"><!--start-->
 <!--
<span class="cube is-red is-lg" style="display: block; margin: 0 auto; padding-top: 0px;">
  <span class="face front">&nbsp;</span>
  <span class="face side">&nbsp;</span>
  <span class="face top">&nbsp;</span>
</span>
-->
 <!--stop-->
 <span>Lectures</span></a></p>
<ul class="menu-list">
<li><a href="/lectures/en">Start</a></li>
<li><a class="is-active" href="#" data-toggle="collapse"
data-target="page-dp-nav">Differential Privacy</a>
<ul class="" id="page-dp-nav">
<li><a href=
"/lectures/en/differential-privacy/introduction">Introduction</a></li>
</ul>
</li>
<li><a class="" href="#" data-toggle="collapse" data-target=
"page-pe-nav">Privacy Engineering</a>
<ul class="is-hidden" id="page-pe-nav">
<li><a href=
"/lectures/en/privacy-engineering/introduction">Introduction</a></li>
<li><a href=
"/lectures/en/privacy-engineering/frameworks">Frameworks</a></li>
<li><a class="" href="#" data-toggle="collapse" data-target=
"page-pe.case-study-nav">Case study</a>
<ul class="is-hidden" id="page-pe.case-study-nav">
<li><a href=
"/lectures/en/privacy-engineering/case-study/introduction">Introduction</a></li>
<li><a href=
"/lectures/en/privacy-engineering/case-study/requirements-analysis">
Requirements analysis</a></li>
<li><a href=
"/lectures/en/privacy-engineering/case-study/guidelines">Guidelines</a></li>
<li><a href=
"/lectures/en/privacy-engineering/case-study/technical-measures">Technical
measures</a></li>
<li><a href=
"/lectures/en/privacy-engineering/case-study/processes">Processes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/lectures/en/contact">Contact</a></li>
<li><a href="#" data-toggle="collapse" data-target=
"menu-language-dropdown">Languages</a>
<ul id="menu-language-dropdown" class="is-hidden">
<li><a class="is-open is-active" href=
"/lectures/en/differential-privacy/introduction">English</a></li>
<li><a class="" href=
"/lectures/differential-privacy/einfuehrung">Deutsch</a></li>
</ul>
</li>
</ul>
</aside>
</div>
<section class="section first wide">
<div class="content markdown with-comments">
<h1>Introduction</h1>
<p>This is an interactive supplement to the lecture "Privacy with
Ɛ-Differential Privacy". Currently, this is not a stand-alone
manuscript and is only really complete in combination with the
presentation, but the content will be continuously expanded and
improved.</p>
<script>
  translations = {"d": {"title": {"_t": {"de": "c387acb26a61e4c3", "en": "c387acb26a61e4c3"}, "de": "Datensatz $ D $", "en": "Data set $ D $"}}, "dp": {"title": {"_t": {"de": "4bf72bbeeb7bc6b9", "en": "4bf72bbeeb7bc6b9"}, "de": "Datensatz $ D\u0027 $", "en": "Data set $ D\u0027 $"}}, "exact": {"calculate-frequencies": {"_t": {"de": "308866d2ae98589b", "en": "308866d2ae98589b"}, "de": "Wir berechnen die H\u00e4ufigkeiten in den Datens\u00e4tzen D und D\u0027", "en": "We calculate the frequencies in data sets D and D\u0027"}, "calculate-mean": {"_t": {"de": "ac3ef9656fc2c879", "en": "ac3ef9656fc2c879"}, "de": "Wir berechnen den Mittelwert der Einkommen", "en": "We calculate the mean value of the incomes"}, "store-value": {"_t": {"de": "f0b1aea6ec112adf", "en": "f0b1aea6ec112adf"}, "de": "Wir speichern die Ergebnisse im \u0027dp\u0027 Objekt", "en": "We store the results in the \u0027dp\u0027 object"}}, "freq": {"_t": {"de": "0c6de9d1b4e7a921", "en": "0c6de9d1b4e7a921"}, "de": "H\u00e4ufigkeit in D", "en": "Frequency in D"}, "freq-d": {"_t": {"de": "61f9bfa511bd1f32", "en": "61f9bfa511bd1f32"}, "de": "H\u00e4ufigkeit in D\u0027", "en": "Frequency in D\u0027"}, "income": {"_t": {"de": "8099bc894b7dc013", "en": "8099bc894b7dc013"}, "de": "Einkommen", "en": "Income"}, "infinite": {"_t": {"de": "360aa4a91c2c8f7a", "en": "360aa4a91c2c8f7a"}, "de": "unendlich", "en": "infinite"}, "name": {"_t": {"de": "dcd1d5223f73b3a9", "en": "dcd1d5223f73b3a9"}, "de": "Name", "en": "Name"}, "of": {"_t": {"de": "43ce6022b9318e93", "en": "43ce6022b9318e93"}, "de": "von", "en": "of"}, "ratio": {"_t": {"de": "ae46664ba67ffee0", "en": "ae46664ba67ffee0"}, "de": "Verh\u00e4ltnis", "en": "Ratio"}, "ratio-with-epsilon": {"_t": {"de": "41cd6b324f228eb4", "en": "41cd6b324f228eb4"}, "de": "Verh\u00e4ltnis (exp(\u03b5))", "en": "Ratio (exp(\u03b5))"}, "result": {"_t": {"de": "9950f5c8dc2cca86", "en": "9950f5c8dc2cca86"}, "de": "Beobachtetes Ergebnis", "en": "Observed result"}};
  language = 'en'
</script>
<h1>Our data</h1>
<p>In the following, we use sample data describing the income of
different individuals. We examine how adding a single data point
changes the outcome of statistical analyses on the dataset, and how
this compromises the privacy of the person to whom the added data
belongs.</p>
<div id="table" data-render=
"DataTable([...this.data.slice(0,10),{name: '...', income: '...'}])">
</div>
<p>In the following, we represent individual records as individual
blocks.</p>
<div style="display: flex; flex-direction: row;">
<div style="margin-right: 10px;">
<h2>Data set $ D $</h2>
<div style="margin-left: 0px;" id="cubes-d" data-render=
"DataCubes({data: dataD, color: 'red'})"></div>
</div>
<div>
<h2>Data set $ D' $</h2>
<div id="cubes-dp" data-render=
"DataCubes({data: data, color: 'green'})"></div>
</div>
</div>
<h1>Data set $ D $</h1>
<p>The dataset $ D $ contains all points from dataset $ D ' $,
except for one which is added to it.</p>
<h1>Data set $ D' $</h1>
<p>The data set $ D' $ is identical to the data set $ D $ except
for a single added data point . In the following, we call this
added data point the difference point.</p>
<script type="module">
  import { renderAll } from '/lectures/static/js/render.js';
  import { random } from '/lectures/static/js/stats.js';
  import { DataTable, SuccessRate, Literal, DataCubes, Cube } from '/lectures/static/js/sites/intro.js';
const firstNames = ['James', 'Robert', 'John', 'Michael', 'Joseph', 'Mary', 'Patricia', 'Jennifer', 'Linda', 'Elizabeth', 'Andreas', 'Christian', 'Thomas', 'Lukas', 'Tristan', 'Isolde', 'Wolfgang', 'Herbert', 'Brunhile']
const lastNames = ['Meier', 'Müller', 'Schmidt', 'Kachelmann','Weintraut', 'Schwarz', 'Manning', 'Johnson', 'Biden', 'Maurer', 'Kemmerling', 'Gott', 'Liefers', 'Duchrow', 'Lohse']
const zipCodes = ['66606', '72070', '80331', '10625', '54315', '12421', '92151']
const randomName = () => `${firstNames[random(firstNames.length)]} ${lastNames[random(lastNames.length)]}`
const randomZipCode = () => zipCodes[random(zipCodes.length)]
const randomAge = () => 24+random(40)
const randomIncome = (age) => 31000+age*500+random(1000)*10-random(1000)*10

  const data = []

  for(let i=0;i<200;i++){
    const age = randomAge()
    data.push({
      income: randomIncome(age),
      name: randomName(),
      age: age,
      zipCode: randomZipCode(),
    })
  }

  const differencePoint = data[random(data.length)]
  const minIncome = Math.floor(differencePoint.income/10000)*10000

  const dataD = data.filter(row => row !== differencePoint)

  window.dp = {
    differencePoint: differencePoint,
    incomeGroup: {
      min: minIncome,
      max: minIncome+10000,
    },
    data: data,
    dataD: dataD,
  }

  renderAll({DataTable, SuccessRate, DataCubes, Literal, n: data.length, Cube, data, dataD})

</script>
<h1>A first statistic</h1>
<p>One of the simplest insights we can gain from our data is the
distribution of the incomes of the individuals in the dataset. To
do this, we first form income groups. For example, a group may
contain all records that have an income between 50-60k€. We then
count the number of records in each group, which corresponds to the
statistical frequency of that group.</p>
<div>\begin{equation} X = X_t = \sum\limits_{i=1}^N x_i
\end{equation}</div>
<p>Where $ x _ i = 1 $ if the income of the data point $ i $ is in
the range of income from group $ g $ $ [E^g _ \mathrm{min}, E^g _
\mathrm{max}] $ , and $ x _ i = 0 $ otherwise:</p>
<div>\begin{equation} x_i = \left\{\begin{array}{rcl} 1 & , & E_i
\in [E^g_\mathrm{min},E^g_\mathrm{max}] \\ 0 & , & E_i \notin
[E^g_\mathrm{min},E^g_\mathrm{max}] \\ \end{array}\right.
\end{equation}</div>
<h2>Conversion to code</h2>
<script type="module">

  const { dp } = window;
  const { data, dataD, incomeGroup } = dp;

  // We calculate the frequencies in data sets D and D'
    const frequency = (d) => 
      d.filter(row => row.income >= incomeGroup.min
                   && row.income < incomeGroup.max).length
  

  // We store the results in the 'dp' object
  dp.exact = {
    count: frequency(data),
    countD: frequency(dataD),
  }

</script>
<div class="highlight">
<div class="tango">
<pre><span class=
"c1">// We calculate the frequencies in data sets D and D'</span>
<span class="w">    </span><span class=
"kd">const</span><span class="w"> </span><span class=
"nx">frequency</span><span class="w"> </span><span class=
"o">=</span><span class="w"> </span><span class=
"p">(</span><span class="nx">d</span><span class=
"p">)</span><span class="w"> </span><span class=
"p">=&gt;</span><span class="w"> </span>
<span class="w">      </span><span class="nx">d</span><span class=
"p">.</span><span class="nx">filter</span><span class=
"p">(</span><span class="nx">row</span><span class=
"w"> </span><span class="p">=&gt;</span><span class=
"w"> </span><span class="nx">row</span><span class=
"p">.</span><span class="nx">income</span><span class=
"w"> </span><span class="o">&gt;=</span><span class=
"w"> </span><span class="nx">incomeGroup</span><span class=
"p">.</span><span class="nx">min</span>
<span class="w">                   </span><span class=
"o">&amp;&</span><span class="w"> </span><span class=
"nx">row</span><span class="p">.</span><span class=
"nx">income</span><span class="w"> </span><span class=
"o">&lt;</span><span class="w"> </span><span class=
"nx">incomeGroup</span><span class="p">.</span><span class=
"nx">max</span><span class="p">).</span><span class=
"nx">length</span>
</pre></div>
</div>
<h2>Result</h2>
<div class="chart box" id="result-exact"></div>
<script type="module">
  import { barChart } from '/lectures/static/js/plotting.js';
  const { dp } = window;
  const left = Math.max(0, dp.exact.count - 20)
  const right = Math.max(0, dp.exact.count + 20)
  const values = []
  const ticks = []
  for(let i=left;i<=right;i++){
    values.push(0)
    ticks.push(i)
  }
  barChart("result-exact", [values], {xTicks: ticks,blocks: [{x: dp.exact.count, class: 'is-green'}, {x: dp.exact.countD, class: 'is-red'}], height: 20});
</script>
<h2>Attack on the anonymized data</h2>
<p>An attacker who knows all data values $x _ i$ except for a
single value $x _ j $ can easily calculate the missing value $ x _
j $ from the result $ X _ t $:</p>
<div>\begin{equation} x_j = X_t - \sum\limits_{i \ne j}^N x_i
\end{equation}</div>
<p>Since the relationship between the output value and the input
values is deterministic, the attacker can predict with 100%
confidence whether the added data point is in the income range
under consideration:</p>
<div data-render="SuccessRate({trials: 100, successes: 100})">
</div>
<h1>Adding noise</h1>
<p>To make such attacks more difficult, we could add a random value
$n$ to the true result value $X _ t$: $ X = X _ t + n $. This makes
it difficult for the attacker to estimate the original value $ x _
j $, because he/she does not know the added random value $ n $:</p>
<div>\begin{equation} x_j = X - \sum\limits_{i \ne j}^N x_i - n
\end{equation}</div>
<p>However, there are still edge cases where such noisy data can
reveal origin values. Here is an example: We add a random value in
the range $[-3, 3]$ to the result from above. We repeat this and
plot the frequency of the observed values. As before, green bars
mark the result for the data set $D$, and red bars mark the result
for the data set $D'$.</p>
<div class="chart box" id="result-with-noise"></div>
<script type="module">
  import { FrequencyTable } from '/lectures/static/js/sites/intro.js';
  import { render } from '/lectures/static/js/render.js';
  import { barChart } from '/lectures/static/js/plotting.js';
  import { random } from '/lectures/static/js/stats.js';
  const { dp } = window;
  const left = Math.max(0, dp.exact.count - 20)
  const right = Math.max(0, dp.exact.count + 20)
  const values = []
  const valuesD = []
  const ticks = []
  for(let i=left;i<=right;i++){
    values.push(0)
    valuesD.push(0)
    ticks.push(i)
  }
  const N = 3
  setInterval(() => {
    let nv, nvD

    const r = () => {
      return random(7)-3
    }

    for(let i=0;i<10;i++){
      nv = r()+dp.exact.count
      values[nv-left] += 1
      nvD = r()+dp.exact.countD
      valuesD[nvD-left] += 1      
    }
    barChart("result-with-noise", [values, valuesD], {classNames: ['is-green', 'is-red'], xTicks: ticks,blocks: [{x: nv, class: 'is-green'}, {x: nvD, class: 'is-red'}], height: 200});
    render(document.getElementById('frequency-table'), FrequencyTable, {values: ticks, frequencies: values, frequenciesD: valuesD})
  }, 500);
</script>
<p>Do you notice a problem here? No? Then take a look at the edges
of the frequency distribution: By adding the difference data set,
the probability distribution shifts to the right by a maximum
amount of 1 (if the data point is part of the group under
consideration). I.e., if an attacker observes the value on the far
right, he/she immediately knows that the data point they are
looking for must be in the group, and has thus uncovered the
person's income. Why? Let's look at the frequencies for this:</p>
<div id="frequency-table"></div>
<p>Crucial for the attacker is the ratio of the probabilities of
the observed values: If a given value in $ D $ and $ D' $ is
equally likely, the attacker can at best only guess how the data
point $ x _ j $ contributed to the result. However, the more the
ratio of one differs from 1, the more information the observed
result provides to the attacker. In the above case, the probability
that an attacker will uncover our data is still 25%!</p>
<p>That is, crucial to the security of our noise-based
anonymization is the minimum (or maximum) ratio of the
probabilities for a given outcome value for the two difference
datasets $ D $ and $ D' $:</p>
<div>\begin{equation} \frac{\mathrm{P}(X = x|D)}{\mathrm{P}(X =
x|D')} \end{equation}</div>
<p>To find the worst possible case, we need to consider this
likelihood ratio over all possible outcome sets:</p>
<div>\begin{equation} \alpha = \max\limits_{x} \frac{\mathrm{P}(X =
x|D)}{\mathrm{P}(X = x|D')} \end{equation}</div>
<p>The higher the value $\alpha$, the more information an attacker
can derive from an observed result value in the worst case. In
practice, we additionally write $\alpha = \exp{\epsilon}$, as this
allows us to estimate the privacy loss even for more complex cases.
Indeed, we often do not want to publish only one statistic, but
equal several. For example, for our income data we might publish a
mean, the frequencies considered above, and quantile values. Each
individual data point would then contribute to all of these values.
Accordingly, we need to consider not only the likelihood ratio for
individual values, but for all values together to obtain an
estimate of the privacy loss. For example, if our data point goes
into two different values $X$ and $Y$, an attacker could again look
at the probabilities for combinations of values $(X, Y)$. If the
values $X$ and $Y$ are independent, then their probabilities
are</p>
<div>\begin{equation} \frac{\mathrm{P}(X = x, Y =
y|D)}{\mathrm{P}(X = x, Y = y|D')} = \frac{\mathrm{P}(X =
x|D)}{\mathrm{P}(X = x|D')}\frac{\mathrm{P}(Y = y|D)}{\mathrm{P}(Y
= y|D')} \le \alpha^2 = \exp{2\epsilon} \end{equation}</div>
<p>assuming that the two probability values satisfy DP with value
$\epsilon$ respectively. In the case that the values $X$ and $Y$
are not independent, the value remains below the bound (the proof
of this is a bit complicated, though). The privacy loss defined
above is thus additive, which is a very useful property: if we know
that we want to publish a total of $n$ results based on a data
value $x$, we can easily estimate the maximum privacy loss as
$n\cdot\epsilon$. We can thus define a <strong>privacy
budget</strong> against which we can plan our publication.</p>
<h2>Example: Geometric mechanism</h2>
<p>The geometric mechanism adds to a discrete result value a random
value whose distribution follows the geometric distribution:</p>
<div>\begin{equation} P(X = x) = (1-p)^n\cdot p
\end{equation}</div>
<p>This distribution applies to the range of values $\mathbb{N}^0 =
{1,2,3,\ldots}$. The geometric distribution can also be two-sided,
i.e. all integer values $\mathbb{N}$ are defined:</p>
<div>\begin{equation} P(X = x) = \left\{ \ \begin{array}{lc} \ p &
x = 0 \\ \ 0.5(1-p)^n\cdot p & x \ne 0 \ \end{array} \ \right.
\end{equation}</div>
<p>The following code snippet implements the two-sided
function:</p>
<script type="module">

  const geometricNoise = (epsilon, symmetric) => {
  let p = Math.exp(-epsilon)
  let pv = Math.random()
  if (symmetric){
    if (pv < (1-p)/(1+p)) {
      return 0
    }
  } else if (pv > p) {
    return 0
  }
  if (p < 1e-6) {
    return 0
  }
  pv = Math.random()
  let pe = 1.0 - p + p*pv
  let k = Math.floor(Math.log(1-pe)/Math.log(p))
  if (symmetric && Math.random() < 0.5) {
    return -k
  }
  return k
}
  

  const frequencies = {}
  for(let i=0;i<10000;i++){
    let v = geometricNoise(0.5, true);
    if (frequencies[v] === undefined)
      frequencies[v] = 0;
    frequencies[v]++;
  }

  const { dp } = window;

  dp.geometricNoise = geometricNoise;

  const sf = Object.entries(frequencies).sort((a, b) => a[0]-b[0]);

  import { barChart } from '/lectures/static/js/plotting.js';

  barChart("geometric-noise-example",
      [sf.map(s => s[1])],
      {xTicks: sf.map(s => s[0])});

</script>
<div class="highlight">
<div class="tango">
<pre><span class="kd">const</span><span class=
"w"> </span><span class="nx">geometricNoise</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">epsilon</span><span class="p">,</span><span class=
"w"> </span><span class="nx">symmetric</span><span class=
"p">)</span><span class="w"> </span><span class=
"p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class=
"w"> </span><span class="nx">p</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="nb">Math</span><span class=
"p">.</span><span class="nx">exp</span><span class=
"p">(</span><span class="o">-</span><span class=
"nx">epsilon</span><span class="p">)</span>
<span class="w">  </span><span class="kd">let</span><span class=
"w"> </span><span class="nx">pv</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="nb">Math</span><span class=
"p">.</span><span class="nx">random</span><span class="p">()</span>
<span class="w">  </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">symmetric</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">pv</span><span class="w"> </span><span class=
"o">&lt;</span><span class="w"> </span><span class=
"p">(</span><span class="mf">1</span><span class=
"o">-</span><span class="nx">p</span><span class=
"p">)</span><span class="o">/</span><span class=
"p">(</span><span class="mf">1</span><span class=
"o">+</span><span class="nx">p</span><span class=
"p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class=
"k">return</span><span class="w"> </span><span class="mf">0</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class=
"w"> </span><span class="k">else</span><span class=
"w"> </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">pv</span><span class="w"> </span><span class=
"o">&gt;</span><span class="w"> </span><span class=
"nx">p</span><span class="p">)</span><span class=
"w"> </span><span class="p">{</span>
<span class="w">    </span><span class=
"k">return</span><span class="w"> </span><span class="mf">0</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">p</span><span class="w"> </span><span class=
"o">&lt;</span><span class="w"> </span><span class=
"mf">1e-6</span><span class="p">)</span><span class=
"w"> </span><span class="p">{</span>
<span class="w">    </span><span class=
"k">return</span><span class="w"> </span><span class="mf">0</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">pv</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="nb">Math</span><span class=
"p">.</span><span class="nx">random</span><span class="p">()</span>
<span class="w">  </span><span class="kd">let</span><span class=
"w"> </span><span class="nx">pe</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="mf">1.0</span><span class=
"w"> </span><span class="o">-</span><span class=
"w"> </span><span class="nx">p</span><span class=
"w"> </span><span class="o">+</span><span class=
"w"> </span><span class="nx">p</span><span class=
"o">*</span><span class="nx">pv</span>
<span class="w">  </span><span class="kd">let</span><span class=
"w"> </span><span class="nx">k</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="nb">Math</span><span class=
"p">.</span><span class="nx">floor</span><span class=
"p">(</span><span class="nb">Math</span><span class=
"p">.</span><span class="nx">log</span><span class=
"p">(</span><span class="mf">1</span><span class=
"o">-</span><span class="nx">pe</span><span class=
"p">)</span><span class="o">/</span><span class=
"nb">Math</span><span class="p">.</span><span class=
"nx">log</span><span class="p">(</span><span class=
"nx">p</span><span class="p">))</span>
<span class="w">  </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">symmetric</span><span class="w"> </span><span class=
"o">&amp;&</span><span class="w"> </span><span class=
"nb">Math</span><span class="p">.</span><span class=
"nx">random</span><span class="p">()</span><span class=
"w"> </span><span class="o">&lt;</span><span class=
"w"> </span><span class="mf">0.5</span><span class=
"p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class=
"k">return</span><span class="w"> </span><span class=
"o">-</span><span class="nx">k</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class=
"w"> </span><span class="nx">k</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="chart box" id="geometric-noise-example"></div>
<script type="module">
  import { FrequencyTable, SuccessRate, Epsilon } from '/lectures/static/js/sites/intro.js';
  import { render } from '/lectures/static/js/render.js';
  import { barChart } from '/lectures/static/js/plotting.js';
  import { random } from '/lectures/static/js/stats.js';
  const { dp } = window;
  const { geometricNoise } = dp;
  const left = Math.max(0, dp.exact.count - 20)
  const right = Math.max(0, dp.exact.count + 20)
  let values = []
  let valuesD = []
  let ticks = []
  let successes = 0
  let epsilon = 0.2
  let trials = 0

  const reset = () => {

    values = []
    valuesD = []
    ticks = []
    successes = 0
    trials = 0

    for(let i=left;i<=right;i++){
      values.push(0)
      valuesD.push(0)
      ticks.push(i)
    }

    window.tests = {
      epsilon: epsilon,
      values: values,
      valuesD: valuesD,
      ticks: ticks,
    }

  }

  window.epsilonChanged = (e) => {
    epsilon = e.target.value
    reset()
  }

  reset()

  const N = 3
  setInterval(() => {
    let nv, nvD, i, iD
    let n = 0
    while(true){
      nv = geometricNoise(epsilon, true)
      nvD = geometricNoise(epsilon, true)
      i = nv-left+dp.exact.count
      iD = nvD-left+dp.exact.countD 
      if (i < 0 || i >= values.length || iD < 0 || iD >= valuesD.length)
        continue // we do not count unplottable values
      values[i] += 1
      valuesD[iD] += 1
      trials++
      if (nv+dp.exact.count >= nvD + dp.exact.countD){
        // an attacker would estimate "yes" if the x > x', no otherwise
        successes++
      }
      if (n++ > 10)
        break
    }

    barChart("result-with-geometric-noise", [values, valuesD], {classNames: ['is-green', 'is-red'], xTicks: ticks,blocks: [{x: nv+dp.exact.count, class: 'is-green'}, {x: nvD+dp.exact.countD, class: 'is-red'}], height: 200});
    render(document.getElementById('frequency-table-geometric'), FrequencyTable, {values: ticks, frequencies: values, frequenciesD: valuesD, epsilon: epsilon})
    render(document.getElementById('success-rate'), SuccessRate, {trials: trials, successes: successes})
    render(document.getElementById('epsilon'), Epsilon, {epsilon: epsilon})
  }, 1000);
</script>
<h3>Epsilon</h3>
<p>Change the value of $ \epsilon $ to get a sense of how the
parameter affects the accuracy of the result values and the
likelihood of success for an attacker. In general, the smaller $
\epsilon $, the lower the potential privacy loss for victims, but
the higher the standard deviation of the resulting data.</p>
<p><input type="range" min="0.05" max="10.0" step="0.1" value="0.2"
onchange="epsilonChanged(event)"> <span id="epsilon"></span></p>
<div class="chart box" id="result-with-geometric-noise"></div>
<div id="frequency-table-geometric"></div>
<div id="success-rate"></div>
<h1>Sensitivity</h1>
<p>In our example above, adding a data point to our data set
changed the result by at most an amount of 1 (since we were
calculating frequencies). But what if we want to calculate a
function where a single data point has a larger effect on the
result? For example, we might be interested in the mean, which is
calculated as</p>
<div>\begin{equation} \bar{E} = \frac{1}{N}\sum\limits_{i=1}^N e_i
\end{equation}</div>
<p>where $e _ i$ is the respective income of a person. The extent
to which a single data point for this function can influence the
result depends on the one hand on the possible range of values (in
this case the possible salary range), and on the other hand on the
number of data points $N$. If $e _ \mathrm{max}$ is the maximum
salary to be considered, the <strong>sensitivity of</strong> the
mean value $\bar{E}$ is therefore approximately</p>
<p>\begin{equation} \delta f(\bar{E}) \approx
\frac{e_\mathrm{max}}{N} - \ldots \end{equation}</p>
<p>Our data set has entries. If we assume a maximum income of
100,000 €, the sensitivity is approximately $\delta f(\bar{E}) = $
. To protect the mean using differential privacy, we would actually
need a different mechanism, since the value is reel and the
geometric mechanism can only be applied to discrete data. However,
we can discretize the mean to be able to process it using the
mechanism. If we choose the discretization interval identical to
the sensitivity $\delta f$, we do not need to modify our mechanism
above. If we want greater accuracy, we need to modify the mechanism
accordingly.</p>
<script type="module">

  const { dp } = window;
    const { data, dataD, incomeGroup } = dp;

    // We calculate the mean value of the incomes
const mean = (d, min, max) => {
  if (d.length === 0)
    throw 'empty list received'
  let m = 0
  d.forEach(row => {
    if (row.income < min || row.income > max)
      throw 'out of bounds value detected'
    m += row.income
  })
  return m/d.length
}
  

    dp.exact = {
      ...dp.exact,
      mean: mean(data),
      meanD: mean(dataD),
    }
</script>
<div class="highlight">
<div class="tango">
<pre><span class=
"c1">// We calculate the mean value of the incomes</span>
<span class="kd">const</span><span class="w"> </span><span class=
"nx">mean</span><span class="w"> </span><span class=
"o">=</span><span class="w"> </span><span class=
"p">(</span><span class="nx">d</span><span class=
"p">,</span><span class="w"> </span><span class=
"nx">min</span><span class="p">,</span><span class=
"w"> </span><span class="nx">max</span><span class=
"p">)</span><span class="w"> </span><span class=
"p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">d</span><span class="p">.</span><span class=
"nx">length</span><span class="w"> </span><span class=
"o">===</span><span class="w"> </span><span class=
"mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">throw</span><span class=
"w"> </span><span class="s1">'empty list received'</span>
<span class="w">  </span><span class="kd">let</span><span class=
"w"> </span><span class="nx">m</span><span class=
"w"> </span><span class="o">=</span><span class=
"w"> </span><span class="mf">0</span>
<span class="w">  </span><span class="nx">d</span><span class=
"p">.</span><span class="nx">forEach</span><span class=
"p">(</span><span class="nx">row</span><span class=
"w"> </span><span class="p">=&gt;</span><span class=
"w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class=
"w"> </span><span class="p">(</span><span class=
"nx">row</span><span class="p">.</span><span class=
"nx">income</span><span class="w"> </span><span class=
"o">&lt;</span><span class="w"> </span><span class=
"nx">min</span><span class="w"> </span><span class=
"o">||</span><span class="w"> </span><span class=
"nx">row</span><span class="p">.</span><span class=
"nx">income</span><span class="w"> </span><span class=
"o">&gt;</span><span class="w"> </span><span class=
"nx">max</span><span class="p">)</span>
<span class="w">      </span><span class=
"k">throw</span><span class="w"> </span><span class=
"s1">'out of bounds value detected'</span>
<span class="w">    </span><span class="nx">m</span><span class=
"w"> </span><span class="o">+=</span><span class=
"w"> </span><span class="nx">row</span><span class=
"p">.</span><span class="nx">income</span>
<span class="w">  </span><span class="p">})</span>
<span class="w">  </span><span class="k">return</span><span class=
"w"> </span><span class="nx">m</span><span class=
"o">/</span><span class="nx">d</span><span class=
"p">.</span><span class="nx">length</span>
<span class="p">}</span>
</pre></div>
</div>
<h1>Testing DP mechanisms</h1>
<script type="module">

  import { render } from '/lectures/static/js/render.js';
  import { barChart } from '/lectures/static/js/plotting.js';

  setInterval(() =&gt; {
    const testStatistic = [];
    const { tests } = window;
    console.log(tests)
    const { values, valuesD, ticks } = tests;
    for(let i=0;i&lt;values.length;i++){
      let ratio = valuesi/valuesDi
      if (ratio &lt; 1.0)
        ratio = 1.0/ratio
      ratio /= Math.exp(tests.epsilon)
      if (isNaN(ratio) || !isFinite(ratio))
        testStatistic.push(0)
      else
        testStatistic.push(ratio)
    }
    barChart("test-statistic", [testStatistic], {hLines: [{y: 1.0, width: 3, color: '#000', style: 'dotted'}], xTicks: ticks, height: 200});    
  }, 1000)
</script>
<div class="chart box" id="test-statistic"></div>
</div>
</section>
</div>
<script defer type="text/javascript" src=
"/lectures/static/js/bulma.js"></script>
</body>
</html>
